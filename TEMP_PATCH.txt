"""Prompt-Generierung für Klassifikation und PCG-Planung."""

from __future__ import annotations

import json
import textwrap
from dataclasses import asdict
from typing import Iterable, Sequence

from auto_pcg.models.schemas import AssetData


class PromptEngine:
    """Erzeugt optimierte Prompts entsprechend der Projektspezifikation."""

    def build_asset_classification_prompt(self, assets: Sequence[AssetData]) -> str:
        """Erstellt einen JSON-fokussierten Prompt für die Asset-Klassifikation."""
        asset_snippets = [
            {
                "asset_path": str(asset.asset_path),
                "asset_type": asset.asset_type,
                "metadata": asdict(asset.metadata),
            }
            for asset in assets
        ]
        asset_json = json.dumps(asset_snippets, ensure_ascii=False, indent=2)
        instructions = textwrap.dedent(
            """
ROLLE: Du bist ein Asset-Klassifikator für Unreal Engine 5.4.
AUFGABE: Ordne jedes Asset mehreren Ebenen zu.

Hauptkategorien (Primary Categories):
- LANDSCAPE (Terrain, Wasser, Höhlen, Klippen, Pfade)
- VEGETATION (Bäume, Büsche, Gräser, Blumen, Pilze, Pflanzen)
- ARCHITECTURE (Gebäude, Ruinen, Brücken, Mauern, Böden, Dächer)
- PROP (Möbel, Container, Waffen, Werkzeuge, Dekoration, Licht)
- CHARACTER (Menschen, Tiere, Kreaturen, Monster)
- EFFECTS (Partikel, Licht, Sound)
- MATERIAL (Oberflächen/Materialdefinitionen)
- BLUEPRINT (Interaktive/technische Blueprints)

Unterkategorien: Wähle passende Begriffe aus den obigen Beispielen (z.B. Tree, Bush,
Terrain, Cliff, Building, Bridge, Furniture, Weapon, Particle, Ground, Interactive).

Tags: Liste aus beschreibenden Begriffen wie Größe (small/medium/large/huge),
Farbe (red/green/dark/bright), Zustand (new/old/broken), Jahreszeit, Umgebung
(indoor/outdoor/underground/underwater), Genre (magical, futuristic, medieval usw.).

Stil (Style): wähle aus {realistic, fantasy, sci-fi, medieval, modern, cartoon,
low-poly, stylized}.

Biomes: kombiniere die am besten passenden aus {forest, desert, mountain, grassland,
tundra, jungle, urban, aquatic, arctic, volcanic}.

Technische Eigenschaften (technical):
- polycount (Ganzzahl, z.B. Vertex-Anzahl)
- texture_resolution (Array [width, height], Ableitung aus Metadaten)
- collision ("simple", "complex" oder "none")
- lod (true/false)
- material_count (Ganzzahl)
Nutze die gelieferten Asset-Metadaten, um vernünftige Werte vorzuschlagen. Wenn
Informationen fehlen, triff eine begründete Schätzung.

ANTWORTFORMAT: Gib ausschließlich valides JSON ohne Markdown zurück:
{"classifications": [ ... ]}. Falls keine Klassifikation möglich ist, antworte mit
{"classifications": []}.

BEISPIEL:
{"classifications": [{
  "asset_path": "/Game/Assets/Trees/SM_Tree_Oak_01",
  "primary_category": "VEGETATION",
  "sub_category": "Tree",
  "tags": ["deciduous","large","forest","nature"],
  "style": "realistic",
  "biomes": ["forest","grassland","urban"],
  "technical": {
    "polycount": 12000,
    "texture_resolution": [2048,2048],
    "collision": "complex",
    "lod": true,
    "material_count": 2
  }
}]}
}]}
"""
        ).strip()
        return f"{instructions}\nASSETS:\n{asset_json}"

    def build_pcg_generation_prompt(self, user_input: str, context: Sequence[AssetData]) -> str:
        """Formuliert den Prompt für die PCG-Planerstellung."""
        asset_list = ", ".join(asset.asset_path.stem for asset in context)
        return (
            "ROLLE: Du bist ein PCG-Architekt für Unreal Engine 5.4.\n"
            f"AUFGABE: Erstelle einen PCG-Plan für den Befehl: {user_input}.\n"
            f"VERFÜGBARE ASSETS: {asset_list}.\n"
            "ANTWORTFORMAT: Gib ausschließlich reines JSON mit dem Objekt 'pcg_plan' zurück. "
            "Kein erläuternder Text, keine Codeblöcke. Falls nicht möglich, antworte mit "
            "{\"pcg_plan\": {\"description\": \"\", \"target_biome\": \"unknown\", \"layers\": []}}."
        )

    def build_asset_selection_prompt(self, biome_type: str, available_assets: Iterable[AssetData]) -> str:
        """Hilfs-Prompt für biome-spezifische Asset-Vorschläge."""
        candidates = [
            {
                "path": str(asset.asset_path),
                "tags": asset.semantic_tags,
                "biomes": asset.semantic_tags,
            }
            for asset in available_assets
        ]
        candidates_json = json.dumps(candidates, ensure_ascii=False, indent=2)
        return (
            "Bitte schlage passende Assets für das folgende Biom vor.\n"
            f"BIOM: {biome_type}\n"
            f"KANDIDATEN:\n{candidates_json}\n"
            "ANTWORT: Nur JSON ohne zusätzlichen Text."
        )

